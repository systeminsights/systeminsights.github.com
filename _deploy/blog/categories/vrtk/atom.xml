<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: vrtk | Manufacturing Big Data]]></title>
  <link href="http://www.manufacturingbigdata.com/blog/categories/vrtk/atom.xml" rel="self"/>
  <link href="http://www.manufacturingbigdata.com/"/>
  <updated>2013-06-12T14:17:38-07:00</updated>
  <id>http://www.manufacturingbigdata.com/</id>
  <author>
    <name><![CDATA[System Insights]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Introducing the vrtk package]]></title>
    <link href="http://www.manufacturingbigdata.com/blog/2013/06/05/introducing-the-vrtk-package/"/>
    <updated>2013-06-05T08:29:00-07:00</updated>
    <id>http://www.manufacturingbigdata.com/blog/2013/06/05/introducing-the-vrtk-package</id>
    <content type="html"><![CDATA[<p>As part of my internship project here at System Insights, Chennai, I&rsquo;ve been involved in developing an R-package called the &lsquo;vrtk&rsquo;, essentially a set of tools for reading and working with data from the vimana platform.</p>

<p>&lsquo;vrtk&rsquo; is short for <em>&lsquo;vimana Research ToolKit&rsquo;</em> or <em>&lsquo;vimana R ToolKit&rsquo;</em>. It is intended to be an open-source set of the basic tools needed to read and work with data.</p>

<p>The library is very simple to use. Visit <a href="https://www.github.com/systeminsights/vrtk">the github page</a> for the download links, the source code, and to find the example files.</p>

<h2>An Example</h2>

<p>The rest of this post will be a simple demonstration &mdash; a rudimentary look at path-feedrate data from a generic machine tool.</p>

<p>The full example script can be found at <a href="https://www.github.com/systeminsights/vrtk/tree/master/example">this link</a>, and it doubles as a tutorial. This post provides just a concise overview.</p>

<h4>Installation and Loading:</h4>

<p>Follow the instructions on the <a href="https://www.github.com/systeminsights/vrtk">same github page</a> to download and install the package. Next, open the <code>example.R</code> script, and follow along with the R-console.</p>

<p>The example file sets up a demo dataset, which has feedrate data and tool position data from a generic machine tool, monitored for around 30 minutes.</p>

<h4>Reading the Data:</h4>

<p>We use some of the core vrtk functions: <code>createDeviceGroupfromGhetto</code>, <code>summary</code>, <code>getDevice</code>, <code>getData</code> and <code>merge</code> to get the data into the right form.</p>

<p>Use the <code>createDeviceGroupfromGhetto</code> method to initialize a device group. Let&rsquo;s call it <code>devGrp</code>.</p>

<pre><code>devGrp &lt;- createDeviceGroupfromGhetto("./402.json",data_folderpath="./402",createRData=TRUE)
</code></pre>

<p>Now, we can store the device itself in a variable.</p>

<pre><code>dev &lt;- getDevice(devGrp)
</code></pre>

<p>The <code>vimana::summary</code> function provides a quick summary of the information present.</p>

<pre><code>summary(devGrp)
summary(dev)
</code></pre>

<p>The summary tells us that the json is associated with a total of 1 device, with 11 DataItems associated.</p>

<p>A DataItem is vrtk&rsquo;s representation of the type of data measured. Examples &mdash; <code>Xload</code>, <code>Yload</code>, <code>Zload</code>, <code>path_feedrate</code>, <code>Xact</code> etc.</p>

<p>The vimana::merge function merges the DataItems we want, and reads them into a dataframe with the appropriate timestamps.</p>

<p>For this example, we want the pathfeedrate data and the position data. So we use merge as follows:</p>

<pre><code>allDataFrame &lt;- merge(dev,"FEEDRATE-ACTUAL|POS")
</code></pre>

<p>After some column-renaming, the data is in a data.frame and ready for use. We can plot the pathfeedrate data with the following command. The resultant plot is shown below.</p>

<pre><code>plot(allDataFrame$timestamp,allDataFrame$reported.path.feedrate,type="s")
</code></pre>

<p><img src="/images/2013-06-05-pathfeedrateplot.png" alt="path.feedrate-plot" /></p>

<h4>The Example Analysis</h4>

<p>For now, we&rsquo;ll simply compute a feedrate from the position data and see how and when it differs from the pathFeedrate data from the same machine during the same duration.</p>

<p>First, we need the distance travelled based on the given position data. Here is a small function to compute it:</p>

<pre><code>dist &lt;- function(xVec,yVec,zVec) { 
  # Euclidean dist
  xDiff = diff(xVec)
  yDiff = diff(yVec)
  zDiff = diff(zVec)
  return(c(NA,sqrt(xDiff^2 + yDiff^2 + zDiff^2)))
}
allDataFrame$prev.dist &lt;- dist(allDataFrame$xPos,allDataFrame$yPos,allDataFrame$zPos)
</code></pre>

<p>Now we just need to compute the distances, and divide by the time difference to get the computed feedrate:</p>

<pre><code>timeDifsVector &lt;- c(NA,diff(allDataFrame$timestamp))
allDataFrame$computed.path.feedrate &lt;- allDataFrame$prev.dist/timeDifsVector
</code></pre>

<p>Now, compute the Pearson correlation coefficient between the reported PathFeedrate and the calculated PathFeedrate from the position data:</p>

<pre><code>cor(allDataFrame$reported.path.feedrate,allDataFrame$computed.path.feedrate,use="na.or.complete")
</code></pre>

<p>This yields a value of ~0.78, which is decent but not as high as expected. What would account for the difference, though?</p>

<p>Let&rsquo;s conclude this example by looking at the difference between the reported and computed feedrates. While the difference does not mean anything in physical terms, it provides a clear picture of where the reported feedrate is differing from the computed one.</p>

<pre><code>difference &lt;- allDataFrame$reported.path.feedrate - allDataFrame$computed.path.feedrate
plot(difference,type="s")
</code></pre>

<p><img src="/images/2013-06-05-diffsplot.png" alt="diffs-plot" /></p>

<p>The difference seems to spike deterministically. We surmise that the spikes correspond to tool changes. This can actually be checked &mdash; we just need to check the toolID data, if its available.</p>

<p>For now, we&rsquo;ll conclude this example by taking a much smaller sampling period, where there aren&rsquo;t any spikes, and check the correlation.</p>

<pre><code>sample.reported &lt;- allDataFrame$reported.path.feedrate[675:740]
sample.computed &lt;- allDataFrame$computed.path.feedrate[675:740]
plot(sample.reported,type="s",ylim=c(-500,2000))
lines(sample.computed,type="s",col="red")
cor(sample.computed,sample.reported)
</code></pre>

<p><img src="/images/2013-06-05-closeupplot.png" alt="closeup-plot" /></p>

<p>97% in the regions between spikes &mdash; not too shabby!</p>

<p>We see several interesting things happening here:
* In regions between spikes, the reported and computed feedrates correlate well.
* While the reported feedrate maintains a particular plateau value for a while, the computed feedrate shows minor fluctuations. Interestingly, using the same position data as in this example, it is possible to see that feedrate fluctuates (usually, the reported is higher), just before the tool takes a sharp turn.
* Also, when there&rsquo;s a change in the plateau value, the computed feedrate always lags for a datapoint or two before reaching the reported value, as one would expect from a real world machine.</p>

<p>That&rsquo;s about it, I suppose! This concludes our trivial example using the vrtk package. Be sure to check out the github page and the documentation for further details and the source-code.</p>
]]></content>
  </entry>
  
</feed>
